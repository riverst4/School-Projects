The design patterns used were MVC and we also used the Observer Design pattern. The MVC was the obvious choice to use for the assignment. Our GUI was within the view, initialization, data was stored in the controller, and data manipulation was done in the model. Whenever a button was pressed in the view, the controller would update some information and then the view would update its view with the new information. It took us time to come up with this pattern. For example, we originally had the data in the model because that’s where data manipulation occurs. This caused a problem where the data wouldn’t be the same at times and we were getting a ton of errors. We then decided that since the data wasn’t the same we could force it to be the same by using a singleton. This ended up working and we began working with a singleton pattern for the model. After feeling guilty of this choice, we realized it would make sense to have the data be in the controller since the controller communicates with both the view and the model. Once we realized this, all previous errors were fixed and that is our design. The view implemented two listeners, an action listener and a mouse listener. The mouse listener was used for selecting an action (act, move take a role). And the action listener was used for selecting rooms to move to or roles to take. The reason for this is due to the fact we were unable to get the role or room name form the mouse listener. However, the action listener made it a lot easier. The mouse listener listens for actions the user can take and the action listener listens for room/role selections. The model is our most cohesive class. If there was more time we may have made better design choices, like making a class for our different components in the view. We had a few button sets and sets of labels that could’ve been in their own class. We did move Casting office into its own class which implements room. We also created a class called shot counter which had some attributes. We found that it made sense to have shot counter as a class. For the extra credit, we added a bot class that will work for the GUI and the console version.

For the Deadwood assignment we got our code running how we wanted it to. As far as we were concerned all aspects of our code were working. Earlier there seemeded to be a rendering issue but that is no longer the case. We experienced a ton of bugs along the way.For example, when a day reset, the shot counter images would not reset. This bug lasted for 3-4 days as the solution wasn’t obvious. The shot counter array, which was supposed to have 22 elements, only had 3, representing the max shot count of a room. This was a nested for loop problem and the solution was to have a count in an inner loop. There were a lot of moving bugs as sometimes a dice would sit on top of other dice, but those were ironed out quickly. If there was more time, we would have made better UI choices, such as more color coordination, more interaction with the board itself instead of buttons and color coded instances. Meaning if it’s yellows turn, some background color would change to yellow. This could’ve been done with a hashmap. It would’ve also been pretty cool to change the view to the current room if a player was in a role as they could only act or rehearse. We ended up implementing a bot so if the player wanted to play by themselves, a bot will finish Deadwood with them as well. 

Assumptions that we made were to make sure the GUI never closed, to make sure dice couldn't sit atop one another, to make sure the user could see what they rolled when acting a scene, and to make it easy to test. We also made the assumption that if a player chooses an action, they can always cancel if they happen to misclick (for moving and taking a role). We did make some assumptions with the bot, we assumed that a player could play the console version with bots so we added an argument that would differentiate between the GUI version and the console version of the game. Lastly, we made the assumption that we don’t need to get the amount of players. 

We would test our code almost after every major edit. When we would identify a bug we would write it down and work on them one at a time. This was important to see if any other aspects would change like an image changing spots. We also used to console to do some testing, it was easy to get paths and some other information from the console rather than the GUI. The code was easy to debug, when there would be a problem it would be clear where the problem occurred. Once we felt that all of the bugs were fixed, we would play a run-through of the game. There has been less testing since the implementation with the bot however. After brief run throughs we felt that there were no major bugs. 

The most challenging aspect was learning the GUI class for the first time and implementing a pattern that we had recently learned. The GUI by far was the most challenging as we had never experienced it before. But once it was learned, it clicked. We did an MVC pattern with an observer pattern. This was hard to conceptualize at first but once we put it in code, with the help of the calculator examples, it was easy to understand.We found that translating the game into code was already pretty interesting but I don’t think we would turn down an idea to make something more interesting. I think building a bot to play instead of a human was also really fun yet challenging.
